printf("Usage: hgdc [opts] command [args]\n\n");
printf(" Commands include:\n");
printf(" hud\t\t\tHeads up display\n");
printf(" q <filename>\tQueue a track\n");
printf(" vo\t\t\tVote-off current track\n");
printf(" ls\t\t\tShow playlist\n\n");
printf(" Options include:\n");
printf(" -e\t\t\tAlways require encryption\n");
printf(" -E\t\t\tRefuse to use encryption\n");
printf(" -h\t\t\tShow this message and exit\n");
printf(" -p port\t\tSet connection port\n");
printf(" -s host/ip\t\tSet connection address\n");
printf(" -u username\t\tSet username\n");
printf(" -x level\t\tSet debug level (0-3)\n");
printf(" -v\t\t\tShow version and exit\n");
printf(" -e\t\t\tEnable Encyption\n");


/* lookup for request despatch */
struct hgd_req_despatch req_desps[] = {
/* cmd, n_args, need_auth, handler */
{"ls", 0, 0, hgd_req_playlist},
{"hud", 0, 0, hgd_req_hud},
{"vo", 0, 1, hgd_req_vote_off},
{"q", 1, 1, hgd_req_queue},
{NULL, 0, 0, NULL} /* terminate */
};



int
hgd_req_playlist(char **args)
{
char *resp, *track_resp, *p;
int n_items, i;

args = args; /* shhh */

hgd_sock_send_line(sock_fd, ssl, "ls");
resp = hgd_sock_recv_line(sock_fd, ssl);
if (hgd_check_svr_response(resp, 0) == HGD_FAIL) {
free(resp);
return (HGD_FAIL);
}

for (p = resp; (*p != 0 && *p != '|'); p ++);
if (*p != '|') {
DPRINTF(HGD_D_ERROR, "didn't find a argument separator");
free(resp);
return (HGD_FAIL);
}

n_items = atoi(++p);
free(resp);

DPRINTF(HGD_D_DEBUG, "expecting %d items in playlist", n_items);
for (i = 0; i < n_items; i++) {
track_resp = hgd_sock_recv_line(sock_fd, ssl);
if (i == 0) {
hgd_hline();
hgd_print_track(track_resp);
/* printf(" 0 votes-offs.\n"); */
hgd_hline();
} else
hgd_print_track(track_resp);

free(track_resp);
}

return (HGD_OK);
}